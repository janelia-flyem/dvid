## DVID — Distributed, Versioned, Image-oriented Dataservice

DVID is a versioned, image-oriented dataservice written to support neural reconstruction, analysis
and visualization efforts at HHMI Janelia Research Center. It provides storage with branched
versioning of a variety of data focused on Connectomics.

## Core Concepts

### Data Instances and Datatypes

Data consists of named instances of various datatypes. Each datatype provides a variety of
functions through a REST HTTP API. There can be many different data instances of a datatype.
For example, there could be instances "segmentation_meshes" and "segmentation_skeletons" of
the "keyvalue" datatype. Each of those instances could hold billions of key-value pairs where
the key is an integer neuron (or body) ID and the value is a byte blob that could be a mesh OBJ
file (for "segmentation_meshes") or a SWC format file (for "segmentation_skeletons").

### Branched Versioning

Data is committed across versions similar to how git stores files at different versions. A
version is identified by a hexadecimal UUID. DVID supports branched versioning so all versions
form a Directed Acyclic Graph (DAG). Requests for data typically require a UUID to determine a
version as well as a unique name to determine the data instance. An example would be the version
b8a54214d9fd40ada115aaa8f0d78b2f and data instance "segmentation_meshes". UUIDs can be truncated
as long as the prefix is sufficient to unambiguously determine the version. Instead of a UUID,
a special string ":master" or ":master^1" can be used to determine a version. The string
":master" refers to the HEAD (or leaf) of the master branch while ":master^1" refers to the
version before the HEAD.

### HTTP API Pattern

For a given data instance X and UUID V, most HTTP endpoints are of the form
"http://my.dvid.com/api/node/V/X/..." where the ellipses could be replaced by a series of
slash-separated parameters. Many endpoints also have query strings for specifying options.

In general, LLMs should only perform reads and not use the POST method.

## Datatypes Reference

DVID provides pluggable data types. Each datatype package's main Go file contains a
`helpMessage` const with detailed HTTP API documentation. Per-datatype API docs are in
separate files in this directory (docs/datatype-*.txt).

### Segmentation and Label Data

- **labelmap** — The primary 64-bit segmentation type. Stores label volumes with multi-scale
  support, supervoxel management, merge/split operations, label indexing, and sparse volume
  queries. Syncs with annotation and labelsz data. This is the most complex and actively used
  label type. See: docs/datatype-labelmap.txt

- **labelblk** — Older block-aligned 64-bit label volumes. Supports raw/isotropic retrieval
  and pseudo-coloring. Can sync with labelvol for sparse representations.
  See: docs/datatype-labelblk.txt

- **labelarray** — Array-based label storage with multi-scale downsampling and label indexing.
  Similar capabilities to labelmap. See helpMessage in datatype/labelarray/labelarray.go.

- **labelvol** — Sparse label volumes using run-length encoding (RLE). Provides memory-efficient
  coarse (block-level) sparse volume representations with merge/split and area deletion.
  See: docs/datatype-labelvol.txt

- **labelsz** — Ranks labels by annotation counts. Maintains per-label statistics on annotation
  types (PreSyn, PostSyn, Gap, Note). Syncs with annotation data. Supports threshold-based
  queries and top-N ranking. See: docs/datatype-labelsz.txt

- **tarsupervoxels** — Binary data blobs keyed by supervoxel ID, typically meshes. Stores data
  in tar format with bulk loading and missing-supervoxel queries.
  See: docs/datatype-tarsupervoxels.txt

### Image Data

- **imageblk** (also known as uint8blk) — Multi-channel image volumes supporting various bit
  depths (uint8, uint16, uint32, uint64, float32). Provides raw and isotropic image retrieval
  with multi-scale support. See: docs/datatype-imageblk.txt

- **imagetile** — Pre-computed multi-resolution image tiles in XY, XZ, and YZ orientations.
  Stores tiles as PNG, JPG, or LZ4 format for fast retrieval.
  See helpMessage in datatype/imagetile/imagetile.go.

- **multichan16** — Multi-channel 16-bit fluorescence image data with channels stored separately
  (not interleaved). Supports up to 3 channels composited into RGBA.
  See helpMessage in datatype/multichan16/multichan16.go.

- **googlevoxels** — Proxy to Google BrainMaps API for multi-scale image tiles and volumes.
  See helpMessage in datatype/googlevoxels/googlevoxels.go.

### Annotations and Metadata

- **annotation** — 3D point annotations (synapses, markers) with spatial indexing. Supports
  querying by location or label, relationships between annotations, and syncing with label data.
  See: docs/datatype-annotation.txt

- **neuronjson** — JSON data for neurons with optimized field-level queries. Manages structured
  neuron metadata with conditional queries and schema support.
  See: docs/datatype-neuronjson.txt

- **keyvalue** — Generic key-value store for arbitrary binary data (JSON, configs, meshes).
  Supports individual key operations, batch operations, and range queries.
  See: docs/datatype-keyvalue.txt

- **roi** — Regions of interest defined as block-level RLE spans. Supports point-in-ROI queries,
  binary mask generation, and partitioning for distributed processing.
  See: docs/datatype-roi.txt

### Common Packages (datatype/common/)

These are shared libraries used by multiple datatypes:

- **labels** — Compressed label block handling, label index structures, merge/split operations
- **downres** — Multi-scale downsampling shared across data types
- **nanovdb** — Pure Go NanoVDB binary format writer for exporting to fVDB
- **proto** — Protocol buffer definitions for label indices

## Server-level HTTP API

These are HTTP endpoints that provide server-level information.

 GET  /api/help

	The current page that lists all general and type-specific commands/HTTP API.

 GET  /api/help/{typename}

	Returns help for the given datatype.

 GET  /api/load

	Returns a JSON of server load statistics.

 GET  /api/storage

 	Returns a JSON object for each backend store where the key is the backend store name.
	The store object has local instance ID keys with the following object value:

	{
		"Name": "grayscale",
		"DataType": "uint8blk",
		"DataUUID": ...,
		"RootUUID": ...,  // this is the UUID of this data's root
		"Bytes": ...
	}

 GET  /api/heartbeat[?u=]

	Preferred method to test whether server is alive.  If a username is provided, the
	time it takes to respond to the request (including transmission to remote client)
	is recorded.  A compilation of user latencies is available through the
	/api/user-latencies endpoint.

GET  /api/server/info

	Returns JSON for server properties.

GET  /api/server/note

	Returns any value of [server.note] from the configuration TOML.

GET  /api/server/config

	Returns the raw content of the configuration TOML.

GET  /api/server/types

	Returns JSON with the datatypes of currently stored data instances.  Datatypes are represented
	by a name and the URL of the reference implementation.  To see all possible datatypes, i.e., the
	list of compiled datatypes, use the "compiled-types" endpoint.

GET  /api/server/compiled-types

 	Returns JSON of all possible datatypes for this server, i.e., the list of compiled datatypes.


## Repository-level HTTP API

These are HTTP endpoints that provide information for a repository.

 GET  /api/repos/info

	Returns JSON for the repositories under management by this server.
	Note that any versioned properties for image-based data instances (e.g., extents)
	will be drawn from the leaf of the master branch.

 HEAD /api/repo/{uuid}

	Returns 200 if a repo with given UUID is available.

 GET  /api/repo/{uuid}/info

	Returns JSON for just the repository with given root UUID.  The UUID string can be
	shortened as long as it is uniquely identifiable across the managed repositories.
	Note that any versioned properties for image-based data instances (e.g., extents)
	will be drawn from the leaf of the master branch.

  GET /api/repo/{uuid}/log
 POST /api/repo/{uuid}/log

	GETs or POSTs log data to the repo with given UUID.  The get or post body should
	be JSON of the following format:

	{ "log": [ "provenance data...", "provenance data...", ...] }

	The log is a list of strings that will be appended to the repo's log.  They should be
	descriptions for the entire repo and not just one node.  For particular versions, use
	node-level logging (below).

  GET /api/repo/{uuid}/branch-versions/{branch name}

	Returns a JSON list of version UUIDs for the given branch name, starting with the
	current leaf and working back to the root.  Use "master" for the default branch.

	If a repository predates the introduction of branch names and has multiple paths
	for the given branch name, the endpoint will return an Bad Request Error (400).


## Datatype-level HTTP API

Each datatype has its own set of HTTP endpoints, and some endpoints are similar across many
different datatypes. For example, "http://my.dvid.com/api/node/V/X/info" returns metadata
for the data instance X that has some version V. The version UUID is necessary because one
DVID server could hold multiple repositories, each with sets of unique UUIDs.

Per-datatype API documentation is in separate files:

  docs/datatype-keyvalue.txt
  docs/datatype-neuronjson.txt
  docs/datatype-imageblk.txt
  docs/datatype-labelmap.txt
  docs/datatype-annotation.txt
  docs/datatype-roi.txt
  docs/datatype-labelblk.txt
  docs/datatype-labelvol.txt
  docs/datatype-labelsz.txt
  docs/datatype-tarsupervoxels.txt

For other datatypes not listed above, see the helpMessage const in each package's main Go file
under datatype/.
